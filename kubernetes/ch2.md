# 쿠버네티스에 실제 애플리케이션 배포

애플리케이션에 배포하는 단위를 파드라고한다.

파드란? 

컨테이너의 집합이 파드입니다. + 볼륨(계속저장되어야하는 데이터 도커에서 배움 mysql) 

쿠버네티스는 컨테이너를 관리하기위한 솔루션(오케스트레이션)이다.

하나의 컨테이너가 하나의 파드로 이루어진게많다.

파드는 어떤 한가지일을 하는것

만약 파드가 죽게된다면 이런걸 방지한 단위가 파드가 여러개있을수있도록 준비해둔 단계가 디플로이먼트이다.

파드를 여러개 사용하는게 파드가 죽으면 대처방안이다.

지금의 쿠버네티스 버전으로는

run은 오직 하나의 파드만 배포가 가능했고, create는 둘다가능하고, apply도 파드랑 디플로이먼트 둘다 가능합니다. apply는 파일을 통해서 배포하는것이다.

디플로이먼트는 파드를 여러번거쳐서 여러개 배포하고

파일을 통해서는 한번에 여러개를 배포할 수 있다.

그런데

`kubectl scale deployment deploy-nginx --replicas=3` 하면은 3개로 바뀌게된다.

여전히 남은것은 3개의 배포된 nginx가 서비스에 노출안된것이라서 이것을 노출시키는방법이다.

아까는 node-exporter를 사용했는데 이번엔 어떨가

`kubectl expose deployment(대상) deploy-nginx(이름 식별자) --type=NodePort --port=80` 을 보면 이제 단위가 파드가 아닌 디플로이먼트이고, 디플로이먼트는 하나의 묶음?단위라고 생각하고 이거를 deploy-nginx로 배포했고 이것을 이제 노드포트로 노출시킨것이다. 감이온다.

그런데 노드포트가 최선의 방법이아니다. 노드의 아이피를 사용자나 접속자에게 알려주는건 위험한것이다. 그래서 디플로이먼트를 노출하는 좋은방법은 로드밸런서라는 타입으로 선언하는게 베스트다 왜냐하면 리버스 프록시이기떄문이다. 뒤의 서버를 숨길 수 있다. 그런데 이제 파드의 모임의 디플로이 먼트라고 생각하자

**Kubernetes에서 Deployment는 파드의 집합을 관리하는 리소스입니다.**

노드포트보다 로드밸런서가 좋은 점 : 노드포트는 아이피가 공개된다. 로드밸런서는 가상 아이피처럼 대표하는 고유의 아이피를 통해 알려줄 수 있다. 로드밸런서를 사용하면 가야할 경로를 최적화 할 수 있다.

쿠버네티스에서 어떤파일이나 코드를 이용해 설치할 때는 apply를 사용하여 설치한다.

그리고 deployment를 통해 할떄는 create 그리고 image에서는 기존의 레포지토리 nginx라고하지만 개인의 경우는 개인의 레포지토리 도커나 컨테이너에서는 레지스트리 라고 불리는 레지스트리 이름을 적어주고 이미지입력해주기??

scale하고 잘 늘려졌는지 확인하려면 kubectl get pods를 하는것은 디플로이먼트는 파드의 집합이기때문이다. 

services는 쿠버네티스에서 돌아가는 서비스목록을 보는것이고

pods는 파드의 목록을 보는것이다. 

nodes는 쿠버네티스의 node목록을 보는것이고

디플로이먼트는 파드의 집합이니까 디플로이먼트의 개수를 3개로 하면 파드가3개가되어서 pods를 보면 파드의 개수가 많아진다.

다시 노출시키는데 사용하는게 노드포트가 아니라 로드밸런서로 사용하는경우는 간단하다 

`kubectl expose deployment chk-hn --type=LoadBalancer --port=80` type을 정해주는것이다.

제일 중요한건 services목록을보면 external IP가 입력이 되어있다는것이다.

따라서 로드밸런서로 한다면 노드포트와는 다르게 내부ip를 알려줄 필요없이 외부아이피만 알려주면 된다.
